<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Kapibara Runner</title>
    <style>
        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #222;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        /* Overlay proszący o obrócenie telefonu (dla małych ekranów w pionie) */
        #rotate-overlay {
            position: fixed;
            inset: 0;
            background: #111;
            color: #fff;
            display: none;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            z-index: 9999;
        }

        #rotate-overlay-inner {
            max-width: 320px;
            margin: 0 auto;
        }

        #rotate-overlay h1 {
            font-size: 22px;
            margin-bottom: 10px;
        }

        #rotate-overlay p {
            font-size: 16px;
            line-height: 1.4;
        }

        /* Główny kontener (gra + Hall of Fame) */
        .container {
            margin: 10px auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 1000px;
            padding: 0 10px 10px;
            box-sizing: border-box;
            align-items: center;
        }

        @media (min-width: 900px) {
            .container {
                align-items: flex-start;
            }
        }

        /* Kontener do skalowania całej gry tak, by mieściła się na ekranie */
        #game-scale {
            position: relative;
        }

        #game-wrapper {
            background: #111;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            width: 800px;       /* bazowa szerokość interfejsu */
            box-sizing: border-box;
        }

        canvas {
            display: block;
            background: #7fd4ff; /* i tak nadpisywane w JS */
            border-radius: 8px;
            width: 100%;
            height: auto;      /* zachowuje proporcje 800x400 */
        }

        #ui {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            gap: 5px;
            flex-wrap: wrap;
        }

        #message {
            margin-top: 8px;
            font-size: 14px;
        }

        #hof-panel {
            background: #111;
            padding: 10px 14px;
            border-radius: 8px;
            min-width: 0;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 400px;
        }

        #hof-panel h2 {
            margin-top: 0;
            font-size: 18px;
            text-align: center;
        }

        #hall-of-fame table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        #hall-of-fame th,
        #hall-of-fame td {
            border-bottom: 1px solid #333;
            padding: 4px 3px;
            text-align: left;
        }

        #hall-of-fame th {
            font-weight: 600;
        }

        #game-over-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
        }

        #game-over-box {
            background: #222;
            border-radius: 10px;
            padding: 16px 20px;
            width: 280px;
            max-width: 90vw;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
        }

        #game-over-box h3 {
            margin-top: 0;
            margin-bottom: 8px;
            text-align: center;
        }

        .row {
            margin-bottom: 8px;
        }

        label {
            font-size: 13px;
        }

        input[type="text"] {
            width: 100%;
            padding: 5px 6px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #111;
            color: #fff;
            box-sizing: border-box;
        }

        .buttons {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: space-between;
        }

        button {
            flex: 1;
            padding: 6px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 13px;
            background: #00c56b;
            color: #000;
            font-weight: 600;
            transition: transform 0.05s ease, box-shadow 0.05s ease;
        }

        button.secondary {
            background: #444;
            color: #fff;
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 0 0 rgba(0,0,0,0);
        }

        /* Drobne zmiany dla bardzo niskich ekranów (mały landscape) */
        @media (max-height: 480px) {
            #ui {
                font-size: 12px;
            }
            #message {
                font-size: 12px;
            }
            button {
                font-size: 12px;
                padding: 4px;
            }
        }
    </style>
</head>
<body>

<!-- Overlay proszący o tryb poziomy na małych urządzeniach w pionie -->
<div id="rotate-overlay">
    <div id="rotate-overlay-inner">
        <h1>Obróć telefon</h1>
        <p>
            Ta gra została zaprojektowana do gry w poziomie (landscape).<br />
            Obróć proszę urządzenie, aby kontynuować.
        </p>
    </div>
</div>

<div class="container" id="main-container">
    <div id="game-scale">
        <div id="game-wrapper">
            <div style="position: relative;">
                <!-- Logiczny rozmiar gry: 800x400 -->
                <canvas id="game" width="800" height="400"></canvas>
                <div id="game-over-overlay">
                    <div id="game-over-box">
                        <h3>Koniec gry</h3>
                        <div class="row">
                            <strong>Twój wynik:</strong> <span id="final-score">0</span>
                        </div>
                        <div class="row">
                            <label for="player-name">Twoje imię (max 5 znaków):</label>
                            <input id="player-name" type="text" maxlength="5" />
                        </div>
                        <div class="buttons">
                            <button id="save-score-btn">Zapisz wynik</button>
                            <button id="restart-btn" class="secondary">Graj ponownie</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="ui">
                <div>Punkty: <span id="score">0</span></div>
                <div>Czas: <span id="time">0.0</span>s</div>
                <div>Poziom prędkości: <span id="speed-indicator">1</span>/10</div>
            </div>
            <div id="message">
                Sterowanie: <strong>Spacja</strong> lub <strong>dotknięcie / kliknięcie w obszar gry</strong><br />
                Kapibara biegnie sama – przeskakuj egzotyczne zwierzęta!
            </div>
        </div>
    </div>

    <div id="hof-panel">
        <h2>Hall of Fame</h2>
        <div id="hall-of-fame">Ładowanie...</div>
    </div>
</div>

<script src="hall_of_fame.js"></script>
<script>
(function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const timeEl = document.getElementById('time');
    const speedIndicatorEl = document.getElementById('speed-indicator');

    const gameOverOverlay = document.getElementById('game-over-overlay');
    const finalScoreEl = document.getElementById('final-score');
    const playerNameInput = document.getElementById('player-name');
    const saveScoreBtn = document.getElementById('save-score-btn');
    const restartBtn = document.getElementById('restart-btn');

    const overlayEl = document.getElementById('rotate-overlay');
    const mainContainerEl = document.getElementById('main-container');
    const scaleContainerEl = document.getElementById('game-scale');
    const gameWrapperEl = document.getElementById('game-wrapper');

    const hofContainer = document.getElementById('hall-of-fame');

    const GRAVITY = 0.5;
    const JUMP_SPEED = -11;
    const GROUND_HEIGHT = 80;

    const BASE_SPEED = 4;

    // 10 poziomów – co 30 sekund:
    // lvl 1..10, punkty 10..100
    const LEVEL_DURATION = 30;          // w sekundach
    const MAX_LEVEL = 10;               // poziomy 1..10
    const SPEED_LEVELS = [1, 1.15, 1.3, 1.45, 1.6, 1.75, 1.9, 2.05, 2.2, 2.35];
    const REWARD_LEVELS = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];

    // Kolory nieba i trawy dla kolejnych poziomów (coraz ciemniejsze)
    const SKY_COLORS = [
        '#7fd4ff',
        '#6dc2ff',
        '#5ab0ff',
        '#479dff',
        '#3589f0',
        '#2f76d0',
        '#2955b0',
        '#233f90',
        '#1c2c70',
        '#151c50'
    ];
    const GRASS_COLORS = [
        '#3ea63e',
        '#36963a',
        '#308636',
        '#2a7633',
        '#24662f',
        '#1e562b',
        '#184627',
        '#123623',
        '#0d261f',
        '#08161b'
    ];

    // Stałe dla przewijania terenu
    const STRIPE_WIDTH = 40;
    const HILL_SEG = 200;

    // Parametry odstępów między przeszkodami (w przestrzeni gry, nie w czasie)
    const MIN_OBSTACLE_DISTANCE = 220;   // minimalny dystans w poziomie między kolejnymi zwierzętami
    const RANDOM_OBSTACLE_DISTANCE = 200; // dodatkowy losowy dystans [0..200]

    const CAPY = {
        x: 80,
        y: 0, // ustawi się niżej
        w: 40,
        h: 30,
        vy: 0,
        onGround: false
    };

    let obstacles = [];
    let distanceSinceLastObstacle = 0;

    // Parallax: osobne offsety dla ziemi i pagórków
    let groundOffset = 0;      // ziemia + kreski (zawsze w zakresie [-STRIPE_WIDTH, 0])
    let hillOffset = 0;        // pagórki w tle (zawsze w zakresie [-HILL_SEG, 0])

    // Chmury – osobne offsety (niezależne od prędkości gry)
    let cloudOffset1 = 0;
    let cloudOffset2 = 0;
    let cloudOffset3 = 0;

    let gameState = 'ready'; // 'ready' | 'running' | 'gameover'
    let startTime = null;
    let lastFrameTime = null;
    let elapsedTime = 0;
    let score = 0;

    let gameOverActionHandled = false;

    // Do skalowania interfejsu gry
    let baseGameWidth = null;
    let baseGameHeight = null;

    function getCurrentLevelIndex() {
        if (!startTime) return 0;
        const levelFromTime = Math.floor(elapsedTime / LEVEL_DURATION);
        return Math.min(levelFromTime, MAX_LEVEL - 1); // indeks 0..9
    }

    function getCurrentSpeed() {
        const lvlIndex = getCurrentLevelIndex();
        return BASE_SPEED * SPEED_LEVELS[lvlIndex];
    }

    function getCurrentReward() {
        const lvlIndex = getCurrentLevelIndex();
        return REWARD_LEVELS[lvlIndex];
    }

    function resetGame() {
        CAPY.y = canvas.height - GROUND_HEIGHT - CAPY.h;
        CAPY.vy = 0;
        CAPY.onGround = true;

        obstacles = [];
        distanceSinceLastObstacle = 0;

        groundOffset = 0;
        hillOffset = 0;
        cloudOffset1 = 0;
        cloudOffset2 = 0;
        cloudOffset3 = 0;

        startTime = null;
        lastFrameTime = null;
        elapsedTime = 0;
        score = 0;
        gameState = 'ready';

        scoreEl.textContent = '0';
        timeEl.textContent = '0.0';
        speedIndicatorEl.textContent = '1';

        gameOverOverlay.style.display = 'none';
        playerNameInput.value = '';

        gameOverActionHandled = false;

        drawFrame(0); // statyczny kadr startowy
    }

    function spawnObstacle() {
        // egzotyczne zwierzęta
        const animalTypes = [
            'słoń', 'małpa', 'krokodyl', 'pantera', 'papuga',
            'wąż', 'nosorożec', 'zebra', 'lew', 'guziec'
        ];
        const type = animalTypes[Math.floor(Math.random() * animalTypes.length)];

        // Bazowe rozmiary zbliżone do wcześniejszych „domowych” zwierząt
        let baseW = 60;
        let baseH = 40;

        switch (type) {
            case 'słoń':
                baseW = 60; baseH = 40; break;
            case 'małpa':
                baseW = 50; baseH = 40; break;
            case 'krokodyl':
                baseW = 60; baseH = 30; break;
            case 'pantera':
                baseW = 60; baseH = 35; break;
            case 'papuga':
                baseW = 40; baseH = 30; break;
            case 'wąż':
                baseW = 60; baseH = 25; break;
            case 'nosorożec':
                baseW = 60; baseH = 45; break;
            case 'zebra':
                baseW = 60; baseH = 45; break;
            case 'lew':
                baseW = 60; baseH = 40; break;
            case 'guziec':
                baseW = 55; baseH = 38; break;
        }

        // Skalowanie rozmiaru zwierzęcia zależnie od poziomu prędkości:
        const lvlIndex = getCurrentLevelIndex(); // 0..9
        const sizeFactor = 1 + lvlIndex * 0.15;   // 1.0, 1.15, 1.3, ...

        const width = baseW * sizeFactor;
        const height = baseH * sizeFactor;

        const x = canvas.width + 20;
        const y = canvas.height - GROUND_HEIGHT - height;

        obstacles.push({
            x,
            y,
            w: width,
            h: height,
            scored: false,
            type
        });
    }

    function maybeSpawnObstacle(speed) {
        // Zliczamy dystans przebytej ziemi (aby odstępy były w jednostkach przestrzeni)
        // speed*dt jest "pikselami na klatkę przy 60FPS", więc distanceSinceLastObstacle
        // też liczymy w pikselach poziomo.
        // Warunki:
        // - min. dystans + losowy margines,
        // - kapibara na ziemi,
        // - ostatnie zwierzę nie za blisko prawej krawędzi.
        if (!CAPY.onGround) return;

        const last = obstacles[obstacles.length - 1];
        if (last && last.x > canvas.width - 120) {
            return; // poprzednie za blisko prawej krawędzi
        }

        if (distanceSinceLastObstacle < MIN_OBSTACLE_DISTANCE) return;

        const extra = Math.random() * RANDOM_OBSTACLE_DISTANCE;
        if (distanceSinceLastObstacle >= MIN_OBSTACLE_DISTANCE + extra) {
            spawnObstacle();
            distanceSinceLastObstacle = 0;
        }
    }

    function doJump() {
        if (gameState === 'ready') {
            startGame();
        }
        if (gameState !== 'running') return;

        if (CAPY.onGround) {
            CAPY.vy = JUMP_SPEED;
            CAPY.onGround = false;
        }
    }

    function startGame() {
        if (gameState === 'running') return;
        gameState = 'running';
        startTime = performance.now();
        lastFrameTime = startTime;
        requestAnimationFrame(gameLoop);
    }

    function endGame() {
        gameState = 'gameover';
        finalScoreEl.textContent = score;
        gameOverOverlay.style.display = 'flex';
    }

    function update(delta, timestamp) {
        const dt = delta / 16.67; // ~60 FPS baseline
        elapsedTime = (timestamp - startTime) / 1000;

        const speed = getCurrentSpeed();
        const lvlIndex = getCurrentLevelIndex();
        speedIndicatorEl.textContent = (lvlIndex + 1).toString();

        // Teren – ziemia (kreski) porusza się z prędkością gry
        groundOffset -= speed * dt;
        while (groundOffset <= -STRIPE_WIDTH) {
            groundOffset += STRIPE_WIDTH;
        }

        // Pagórki w tle – wolniej (parallax)
        hillOffset -= speed * 0.4 * dt;
        while (hillOffset <= -HILL_SEG) {
            hillOffset += HILL_SEG;
        }

        // Chmury – powoli, niezależnie od prędkości gry
        cloudOffset1 -= 0.3 * dt;
        cloudOffset2 -= 0.2 * dt;
        cloudOffset3 -= 0.1 * dt;

        // Kapibara – fizyka skoku
        CAPY.vy += GRAVITY * dt;
        CAPY.y += CAPY.vy * dt;

        const groundY = canvas.height - GROUND_HEIGHT - CAPY.h;
        if (CAPY.y >= groundY) {
            CAPY.y = groundY;
            CAPY.vy = 0;
            CAPY.onGround = true;
        }

        // Dystans od ostatniej przeszkody (w pikselach gry)
        distanceSinceLastObstacle += speed * dt * 16.67; // skalowanie do "px na 60FPS"

        // Próba wygenerowania nowej przeszkody
        maybeSpawnObstacle(speed);

        // Przeszkody
        for (let i = obstacles.length - 1; i >= 0; i--) {
            const o = obstacles[i];
            o.x -= speed * dt;

            // Kolizja (prosta AABB)
            if (rectOverlap(CAPY, o)) {
                endGame();
                return;
            }

            // Punkty za minięcie zwierzęcia
            if (!o.scored && (o.x + o.w) < CAPY.x) {
                o.scored = true;
                score += getCurrentReward();
                scoreEl.textContent = score;
            }

            // Usuwanie poza ekranem
            if (o.x + o.w < -50) {
                obstacles.splice(i, 1);
            }
        }

        timeEl.textContent = elapsedTime.toFixed(1);
    }

    function rectOverlap(a, b) {
        return (
            a.x < b.x + b.w &&
            a.x + a.w > b.x &&
            a.y < b.y + b.h &&
            a.y + a.h > b.y
        );
    }

    function drawBackground(time) {
        const groundY = canvas.height - GROUND_HEIGHT;
        const lvlIndex = getCurrentLevelIndex();
        const skyColor = SKY_COLORS[lvlIndex] || SKY_COLORS[SKY_COLORS.length - 1];
        const grassColor = GRASS_COLORS[lvlIndex] || GRASS_COLORS[GRASS_COLORS.length - 1];

        // Niebo
        ctx.fillStyle = skyColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Słońce – nieruchome
        ctx.save();
        ctx.fillStyle = '#FFD54F';
        ctx.beginPath();
        ctx.arc(canvas.width - 80, 70, 40, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Chmury – poruszają się powoli w poziomie
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        const cloudBaseY1 = 70;
        const cloudBaseY2 = 120;
        const cloudBaseY3 = 50;
        const cloudSpacing = 220;

        const c1 = ((cloudOffset1 % cloudSpacing) + cloudSpacing) % cloudSpacing;
        const c2 = ((cloudOffset2 % cloudSpacing) + cloudSpacing) % cloudSpacing;
        const c3 = ((cloudOffset3 % cloudSpacing) + cloudSpacing) % cloudSpacing;

        for (let x = -c1; x < canvas.width + cloudSpacing; x += cloudSpacing) {
            drawCloud(x, cloudBaseY1);
        }
        for (let x = -c2; x < canvas.width + cloudSpacing; x += cloudSpacing) {
            drawCloud(x, cloudBaseY2, 0.8);
        }
        for (let x = -c3; x < canvas.width + cloudSpacing; x += cloudSpacing) {
            drawCloud(x, cloudBaseY3, 0.7);
        }
        ctx.restore();

        // Ziemia
        ctx.fillStyle = '#5b3b1f';
        ctx.fillRect(0, groundY, canvas.width, GROUND_HEIGHT);

        // Trawa (kolor zależny od poziomu)
        ctx.fillStyle = grassColor;
        ctx.fillRect(0, groundY, canvas.width, 8);

        // Linie na ziemi (scrollujące razem z terenem)
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        for (let x = groundOffset; x < canvas.width + STRIPE_WIDTH; x += STRIPE_WIDTH) {
            ctx.fillRect(x, groundY + 12, 20, 3);
        }

        // Pagórki w tle – wolniej (parallax)
        ctx.fillStyle = 'rgba(0, 100, 0, 0.5)';
        const hillY = groundY - 60;
        for (let x = hillOffset - HILL_SEG; x < canvas.width + HILL_SEG; x += HILL_SEG) {
            ctx.beginPath();
            ctx.moveTo(x, groundY);
            ctx.quadraticCurveTo(x + 100, hillY - 30, x + 200, groundY);
            ctx.closePath();
            ctx.fill();
        }
    }

    function drawCloud(cx, cy, scale = 1) {
        const w = 70 * scale;
        const h = 35 * scale;

        ctx.beginPath();
        ctx.ellipse(cx, cy, w * 0.6, h * 0.6, 0, 0, Math.PI * 2);
        ctx.ellipse(cx - w * 0.4, cy + 5 * scale, w * 0.45, h * 0.45, 0, 0, Math.PI * 2);
        ctx.ellipse(cx + w * 0.4, cy + 2 * scale, w * 0.4, h * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawCapybara(time) {
        // Ciało
        ctx.fillStyle = '#b97a57';
        ctx.fillRect(CAPY.x, CAPY.y, CAPY.w, CAPY.h);

        // Głowa (po prawej)
        ctx.fillRect(CAPY.x + CAPY.w - 10, CAPY.y + 5, 18, 16);

        // Oko
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(CAPY.x + CAPY.w + 4, CAPY.y + 10, 2, 0, Math.PI * 2);
        ctx.fill();

        // Nóżki – animacja biegu
        const legPhase = Math.sin(time / 80);
        const legOffset = legPhase * 2;
        ctx.fillRect(CAPY.x + 5, CAPY.y + CAPY.h, 6, 8 + legOffset);
        ctx.fillRect(CAPY.x + CAPY.w - 12, CAPY.y + CAPY.h, 6, 8 - legOffset);
    }

    // Rysowanie egzotycznych zwierząt, zwróconych w LEWĄ stronę (głowa po lewej)
    function drawAnimal(o, time) {
        const { x, y, w, h, type } = o;

        switch (type) {
            case 'słoń':
                drawElephant(x, y, w, h, time);
                break;
            case 'małpa':
                drawMonkey(x, y, w, h, time);
                break;
            case 'krokodyl':
                drawCrocodile(x, y, w, h, time);
                break;
            case 'pantera':
                drawPanther(x, y, w, h, time);
                break;
            case 'papuga':
                drawParrot(x, y, w, h, time);
                break;
            case 'wąż':
                drawSnake(x, y, w, h, time);
                break;
            case 'nosorożec':
                drawRhino(x, y, w, h, time);
                break;
            case 'zebra':
                drawZebra(x, y, w, h, time);
                break;
            case 'lew':
                drawLion(x, y, w, h, time);
                break;
            case 'guziec':
                drawWarthog(x, y, w, h, time);
                break;
            default:
                ctx.fillStyle = '#4b2e16';
                ctx.fillRect(x, y, w, h);
        }
    }

    function drawElephant(x, y, w, h, time) {
        ctx.fillStyle = '#9ea7b8';
        // tułów
        ctx.fillRect(x + w * 0.3, y + h * 0.3, w * 0.6, h * 0.6);
        // głowa (po lewej)
        ctx.fillRect(x, y + h * 0.25, w * 0.35, h * 0.5);
        // trąba w lewo
        ctx.fillRect(x - w * 0.15, y + h * 0.45, w * 0.15, h * 0.15);

        // nogi – animacja
        const phase = Math.sin(time / 120);
        const legDelta = phase * (h * 0.08);

        ctx.fillRect(x + w * 0.35, y + h * 0.8, w * 0.12, h * 0.2 + legDelta);
        ctx.fillRect(x + w * 0.6, y + h * 0.8, w * 0.12, h * 0.2 - legDelta);

        // ucho
        ctx.fillRect(x + w * 0.1, y + h * 0.3, w * 0.15, h * 0.25);
    }

    function drawMonkey(x, y, w, h, time) {
        ctx.fillStyle = '#8b5a2b';
        // tułów
        ctx.fillRect(x + w * 0.35, y + h * 0.35, w * 0.45, h * 0.5);
        // głowa
        ctx.beginPath();
        ctx.arc(x + w * 0.25, y + h * 0.45, h * 0.22, 0, Math.PI * 2);
        ctx.fill();
        // twarz jaśniejsza
        ctx.fillStyle = '#c49a6c';
        ctx.beginPath();
        ctx.ellipse(x + w * 0.25, y + h * 0.5, w * 0.18, h * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        // nogi – animacja
        ctx.fillStyle = '#8b5a2b';
        const phase = Math.sin(time / 120);
        const legDelta = phase * (h * 0.08);
        ctx.fillRect(x + w * 0.4, y + h * 0.8, w * 0.08, h * 0.2 + legDelta);
        ctx.fillRect(x + w * 0.6, y + h * 0.8, w * 0.08, h * 0.2 - legDelta);

        // ogon (z prawej)
        ctx.strokeStyle = '#8b5a2b';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x + w * 0.8, y + h * 0.4);
        ctx.quadraticCurveTo(x + w * 0.95, y + h * 0.2, x + w * 0.9, y + h * 0.05);
        ctx.stroke();
    }

    function drawCrocodile(x, y, w, h, time) {
        ctx.fillStyle = '#2e7d32';
        // ciało
        ctx.fillRect(x + w * 0.2, y + h * 0.4, w * 0.7, h * 0.4);
        // głowa po lewej
        ctx.fillRect(x, y + h * 0.35, w * 0.25, h * 0.4);
        // grzbietowe zęby
        ctx.fillStyle = '#1b5e20';
        for (let i = 0; i < 6; i++) {
            const cx = x + w * (0.25 + i * 0.1);
            const cy = y + h * 0.35;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + 6, cy - 8);
            ctx.lineTo(cx + 12, cy);
            ctx.closePath();
            ctx.fill();
        }
        // nogi – mała animacja
        ctx.fillStyle = '#2e7d32';
        const phase = Math.sin(time / 140);
        const legDelta = phase * (h * 0.05);
        ctx.fillRect(x + w * 0.25, y + h * 0.8, w * 0.1, h * 0.15 + legDelta);
        ctx.fillRect(x + w * 0.6, y + h * 0.8, w * 0.1, h * 0.15 - legDelta);
    }

    function drawPanther(x, y, w, h, time) {
        ctx.fillStyle = '#111';
        // tułów
        ctx.fillRect(x + w * 0.3, y + h * 0.35, w * 0.6, h * 0.4);
        // głowa po lewej
        ctx.fillRect(x + w * 0.1, y + h * 0.3, w * 0.25, h * 0.3);
        // uszy
        ctx.beginPath();
        ctx.moveTo(x + w * 0.15, y + h * 0.3);
        ctx.lineTo(x + w * 0.18, y + h * 0.18);
        ctx.lineTo(x + w * 0.22, y + h * 0.3);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + w * 0.24, y + h * 0.3);
        ctx.lineTo(x + w * 0.27, y + h * 0.18);
        ctx.lineTo(x + w * 0.31, y + h * 0.3);
        ctx.closePath();
        ctx.fill();
        // nogi – animacja
        const phase = Math.sin(time / 110);
        const legDelta = phase * (h * 0.07);
        ctx.fillRect(x + w * 0.35, y + h * 0.75, w * 0.1, h * 0.25 + legDelta);
        ctx.fillRect(x + w * 0.6, y + h * 0.75, w * 0.1, h * 0.25 - legDelta);
        // ogon w górę
        ctx.beginPath();
        ctx.moveTo(x + w * 0.9, y + h * 0.45);
        ctx.quadraticCurveTo(x + w, y + h * 0.25, x + w * 0.95, y + h * 0.1);
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 4;
        ctx.stroke();
    }

    function drawParrot(x, y, w, h, time) {
        // Papuga – inny wygląd i animacja lotu (falowanie w pionie + machanie skrzydłami)
        const flapPhase = Math.sin(time / 120);
        const floatPhase = Math.sin(time / 350);
        const dy = floatPhase * (h * 0.1); // lekki ruch góra-dół

        const bodyCx = x + w * 0.4;
        const bodyCy = y + h * 0.55 + dy;

        // ciało (owal)
        ctx.fillStyle = '#43a047';
        ctx.beginPath();
        ctx.ellipse(bodyCx, bodyCy, w * 0.3, h * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();

        // głowa
        ctx.fillStyle = '#e53935';
        ctx.beginPath();
        ctx.arc(x + w * 0.2, y + h * 0.4 + dy, h * 0.2, 0, Math.PI * 2);
        ctx.fill();

        // dziób w lewo
        ctx.fillStyle = '#ffca28';
        ctx.beginPath();
        ctx.moveTo(x + w * 0.05, y + h * 0.4 + dy);
        ctx.lineTo(x, y + h * 0.37 + dy);
        ctx.lineTo(x, y + h * 0.43 + dy);
        ctx.closePath();
        ctx.fill();

        // skrzydła – machanie (przez zmianę położenia):
        const wingOffset = flapPhase * (h * 0.15);
        ctx.fillStyle = '#1e88e5';
        ctx.beginPath();
        ctx.ellipse(bodyCx + w * 0.05, bodyCy + wingOffset, w * 0.25, h * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();

        // ogon (pióra)
        ctx.fillStyle = '#8e24aa';
        ctx.beginPath();
        ctx.moveTo(bodyCx + w * 0.25, bodyCy + h * 0.1);
        ctx.lineTo(bodyCx + w * 0.38, bodyCy + h * 0.35);
        ctx.lineTo(bodyCx + w * 0.18, bodyCy + h * 0.3);
        ctx.closePath();
        ctx.fill();

        // małe nogi pod ciałem (widoczne tylko lekko)
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(bodyCx - w * 0.03, bodyCy + h * 0.25, w * 0.03, h * 0.12);
        ctx.fillRect(bodyCx + w * 0.02, bodyCy + h * 0.25, w * 0.03, h * 0.12);
    }

    function drawSnake(x, y, w, h, time) {
        ctx.fillStyle = '#4caf50';
        // ciało - falujący pasek od prawej do lewej z animacją pełzania
        const segments = 8;
        const segmentWidth = w / segments;
        const phaseBase = time / 160;

        ctx.beginPath();
        ctx.moveTo(x + w, y + h * 0.6);
        for (let i = 0; i <= segments; i++) {
            const px = x + w - i * segmentWidth;
            const offset = Math.sin(phaseBase + i * 0.8) * h * 0.2;
            ctx.lineTo(px, y + h * 0.6 + offset);
        }
        ctx.lineWidth = h * 0.3;
        ctx.strokeStyle = '#4caf50';
        ctx.stroke();

        // głowa po lewej
        ctx.fillStyle = '#43a047';
        ctx.fillRect(x, y + h * 0.45, w * 0.15, h * 0.3);
    }

    function drawRhino(x, y, w, h, time) {
        ctx.fillStyle = '#757575';
        // tułów
        ctx.fillRect(x + w * 0.35, y + h * 0.35, w * 0.55, h * 0.5);
        // głowa po lewej
        ctx.fillRect(x + w * 0.1, y + h * 0.3, w * 0.3, h * 0.4);
        // róg
        ctx.fillStyle = '#bdbdbd';
        ctx.beginPath();
        ctx.moveTo(x, y + h * 0.35);
        ctx.lineTo(x - w * 0.1, y + h * 0.3);
        ctx.lineTo(x - w * 0.05, y + h * 0.4);
        ctx.closePath();
        ctx.fill();
        // nogi – animacja
        ctx.fillStyle = '#757575';
        const phase = Math.sin(time / 130);
        const legDelta = phase * (h * 0.06);
        ctx.fillRect(x + w * 0.4, y + h * 0.8, w * 0.12, h * 0.2 + legDelta);
        ctx.fillRect(x + w * 0.65, y + h * 0.8, w * 0.12, h * 0.2 - legDelta);
    }

    function drawZebra(x, y, w, h, time) {
        ctx.fillStyle = '#fafafa';
        // tułów
        ctx.fillRect(x + w * 0.3, y + h * 0.35, w * 0.6, h * 0.45);
        // paski
        ctx.fillStyle = '#212121';
        for (let i = 0; i < 6; i++) {
            const sx = x + w * (0.32 + i * 0.1);
            ctx.fillRect(sx, y + h * 0.35, w * 0.03, h * 0.45);
        }
        // głowa
        ctx.fillStyle = '#fafafa';
        ctx.fillRect(x + w * 0.1, y + h * 0.3, w * 0.25, h * 0.3);
        ctx.fillStyle = '#212121';
        ctx.fillRect(x + w * 0.12, y + h * 0.32, w * 0.04, h * 0.2); // pasek na głowie
        // uszy
        ctx.beginPath();
        ctx.moveTo(x + w * 0.15, y + h * 0.3);
        ctx.lineTo(x + w * 0.18, y + h * 0.18);
        ctx.lineTo(x + w * 0.21, y + h * 0.3);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + w * 0.23, y + h * 0.3);
        ctx.lineTo(x + w * 0.26, y + h * 0.18);
        ctx.lineTo(x + w * 0.29, y + h * 0.3);
        ctx.closePath();
        ctx.fill();
        // nogi – animacja
        const phase = Math.sin(time / 120);
        const legDelta = phase * (h * 0.07);
        ctx.fillRect(x + w * 0.35, y + h * 0.8, w * 0.1, h * 0.2 + legDelta);
        ctx.fillRect(x + w * 0.6, y + h * 0.8, w * 0.1, h * 0.2 - legDelta);
        // ogon
        ctx.fillRect(x + w * 0.88, y + h * 0.45, w * 0.05, h * 0.3);
    }

    function drawLion(x, y, w, h, time) {
        ctx.fillStyle = '#f9a825';
        // tułów
        ctx.fillRect(x + w * 0.35, y + h * 0.4, w * 0.55, h * 0.4);
        // głowa po lewej z grzywą
        ctx.fillStyle = '#ffb300';
        ctx.beginPath();
        ctx.arc(x + w * 0.25, y + h * 0.5, h * 0.23, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#f57f17';
        ctx.beginPath();
        ctx.arc(x + w * 0.25, y + h * 0.5, h * 0.3, 0, Math.PI * 2);
        ctx.fill();
        // nogi – animacja
        ctx.fillStyle = '#f9a825';
        const phase = Math.sin(time / 115);
        const legDelta = phase * (h * 0.07);
        ctx.fillRect(x + w * 0.4, y + h * 0.8, w * 0.1, h * 0.2 + legDelta);
        ctx.fillRect(x + w * 0.65, y + h * 0.8, w * 0.1, h * 0.2 - legDelta);
        // ogon
        ctx.beginPath();
        ctx.moveTo(x + w * 0.9, y + h * 0.45);
        ctx.quadraticCurveTo(x + w, y + h * 0.4, x + w * 0.98, y + h * 0.3);
        ctx.strokeStyle = '#f9a825';
        ctx.lineWidth = 3;
        ctx.stroke();
    }

    function drawWarthog(x, y, w, h, time) {
        ctx.fillStyle = '#8d6e63';
        // tułów
        ctx.fillRect(x + w * 0.35, y + h * 0.4, w * 0.55, h * 0.4);
        // głowa po lewej
        ctx.fillRect(x + w * 0.1, y + h * 0.35, w * 0.3, h * 0.35);
        // kły
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(x + w * 0.1, y + h * 0.55);
        ctx.lineTo(x, y + h * 0.5);
        ctx.lineTo(x + w * 0.05, y + h * 0.6);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + w * 0.1, y + h * 0.45);
        ctx.lineTo(x, y + h * 0.4);
        ctx.lineTo(x + w * 0.05, y + h * 0.5);
        ctx.closePath();
        ctx.fill();
        // nogi – animacja
        ctx.fillStyle = '#8d6e63';
        const phase = Math.sin(time / 125);
        const legDelta = phase * (h * 0.06);
        ctx.fillRect(x + w * 0.4, y + h * 0.8, w * 0.1, h * 0.2 + legDelta);
        ctx.fillRect(x + w * 0.65, y + h * 0.8, w * 0.1, h * 0.2 - legDelta);
        // grzywa na grzbiecie
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(x + w * 0.45, y + h * 0.32, w * 0.2, h * 0.08);
    }

    function drawObstacles(time) {
        obstacles.forEach(o => {
            drawAnimal(o, time);
        });
    }

    function drawFrame(time) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground(time);
        drawObstacles(time);
        drawCapybara(time);
    }

    function gameLoop(timestamp) {
        if (gameState !== 'running') {
            drawFrame(timestamp);
            return;
        }

        if (!lastFrameTime) lastFrameTime = timestamp;
        const delta = timestamp - lastFrameTime;
        lastFrameTime = timestamp;

        update(delta, timestamp);
        drawFrame(timestamp);

        if (gameState === 'running') {
            requestAnimationFrame(gameLoop);
        }
    }

    // Sterowanie – klawiatura (spacja)
    window.addEventListener('keydown', (e) => {
        if (e.code !== 'Space') return;

        const tag = e.target.tagName.toLowerCase();
        if (tag === 'input' || tag === 'textarea' || e.target.isContentEditable) {
            return;
        }

        e.preventDefault();
        if (gameState === 'gameover') return;
        doJump();
    });

    // Sterowanie – dotyk / kliknięcie dla gry
    function handleTap() {
        if (gameState === 'gameover') return;
        doJump();
    }

    // Kliknięcia myszą – tylko w obszarze gry, nie w okienku game over
    window.addEventListener('mousedown', (e) => {
        if (e.target.closest('#game-over-box')) return;
        if (!e.target.closest('#game-wrapper')) return;
        handleTap();
    });

    // Dotyk – tylko obszar gry, nie okno game over
    window.addEventListener('touchstart', (e) => {
        const target = e.target;

        if (target.closest('#game-over-box')) {
            return;
        }

        if (!target.closest('#game-wrapper')) {
            return;
        }

        if (gameState === 'gameover') return;

        e.preventDefault();
        handleTap();
    }, { passive: false });

    function handleSaveScore() {
        if (gameOverActionHandled) return;
        gameOverActionHandled = true;

        const name = (playerNameInput.value || '').toUpperCase().substring(0, 5) || '???';
        if (window.hof && typeof window.hof.addScore === 'function') {
            window.hof.addScore(name, score);
            window.hof.render(hofContainer);
        }

        resetGame();
    }

    function handleRestart() {
        if (gameOverActionHandled) return;
        gameOverActionHandled = true;
        resetGame();
    }

    // Game over – obsługa przycisków (klik)
    saveScoreBtn.addEventListener('click', (e) => {
        e.preventDefault();
        handleSaveScore();
    });

    restartBtn.addEventListener('click', (e) => {
        e.preventDefault();
        handleRestart();
    });

    // Game over – obsługa przycisków (tap na telefonie)
    saveScoreBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleSaveScore();
    }, { passive: false });

    restartBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleRestart();
    }, { passive: false });

    // Skalowanie interfejsu gry, aby mieścił się w oknie
    function resizeGameArea() {
        if (!gameWrapperEl || !scaleContainerEl) return;

        gameWrapperEl.style.transform = 'scale(1)';
        gameWrapperEl.style.transformOrigin = 'top left';

        if (baseGameWidth === null || baseGameHeight === null) {
            baseGameWidth = gameWrapperEl.offsetWidth;
            baseGameHeight = gameWrapperEl.offsetHeight;
        }

        if (!baseGameWidth || !baseGameHeight) return;

        const padding = 10;
        const availWidth = window.innerWidth - padding * 2;
        const availHeight = window.innerHeight - padding * 2;

        const scale = Math.min(
            availWidth / baseGameWidth,
            availHeight / baseGameHeight,
            1
        );

        gameWrapperEl.style.transform = 'scale(' + scale + ')';
        gameWrapperEl.style.transformOrigin = 'top left';

        scaleContainerEl.style.width = (baseGameWidth * scale) + 'px';
        scaleContainerEl.style.height = (baseGameHeight * scale) + 'px';
    }

    // Pokazywanie/ukrywanie overlayu "obróć telefon" + skalowanie
    function updateLayout() {
        if (!mainContainerEl || !overlayEl) return;

        const isPortrait = window.innerHeight > window.innerWidth;
        const isSmallDevice = window.innerWidth < 900;

        if (isPortrait && isSmallDevice) {
            overlayEl.style.display = 'flex';
            mainContainerEl.style.display = 'none';
        } else {
            overlayEl.style.display = 'none';
            mainContainerEl.style.display = 'flex';
            resizeGameArea();
        }
    }

    // Inicjalizacja – Hall of Fame lokalny
    if (window.hof && typeof window.hof.render === 'function') {
        window.hof.render(hofContainer);
    }

    // Start – statyczny ekran
    resetGame();

    // Ustawienie layoutu i skalowanie na starcie oraz przy zmianie rozmiaru / orientacji
    updateLayout();
    window.addEventListener('resize', updateLayout);

})();
</script>
</body>
</html>
