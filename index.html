<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Kapibara Runner</title>
    <style>
        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #222;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        /* Informacja o konieczności obrócenia telefonu (portret) */
        #rotate-overlay {
            position: fixed;
            inset: 0;
            background: #111;
            color: #fff;
            display: none;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            z-index: 9999;
        }

        #rotate-overlay-inner {
            max-width: 320px;
            margin: 0 auto;
        }

        #rotate-overlay h1 {
            font-size: 22px;
            margin-bottom: 10px;
        }

        #rotate-overlay p {
            font-size: 16px;
            line-height: 1.4;
        }

        /* Główny kontener gry */
        .container {
            margin: 10px auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 1000px;
            padding: 0 10px 10px;
            box-sizing: border-box;
        }

        /* Na większych/niskich, szerokich ekranach – gra + hall of fame obok siebie */
        @media (min-width: 800px) and (orientation: landscape) {
            .container {
                flex-direction: row;
                align-items: flex-start;
            }
        }

        /* Na bardzo niskich ekranach zmniejszamy trochę UI, żeby się zmieścił */
        @media (max-height: 480px) {
            #ui {
                font-size: 12px;
            }
            #message {
                font-size: 12px;
            }
            button {
                font-size: 12px;
                padding: 4px;
            }
        }

        /* W trybie pionowym ukrywamy grę, pokazujemy overlay "obróć telefon" */
        @media (orientation: portrait) {
            .container {
                display: none;
            }
            #rotate-overlay {
                display: flex;
            }
        }

        #game-wrapper {
            background: #111;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            flex: 2;
            min-width: 0;
        }

        canvas {
            display: block;
            background: linear-gradient(#7fd4ff, #b5e8ff);
            border-radius: 8px;
            width: 100%;     /* skalowanie do szerokości ekranu */
            height: auto;    /* proporcje z atrybutów width/height */
        }

        #ui {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            gap: 5px;
            flex-wrap: wrap;
        }

        #message {
            margin-top: 8px;
            font-size: 14px;
        }

        #hof-panel {
            background: #111;
            padding: 10px 14px;
            border-radius: 8px;
            min-width: 0;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            flex: 1;
        }

        #hof-panel h2 {
            margin-top: 0;
            font-size: 18px;
            text-align: center;
        }

        #hall-of-fame table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        #hall-of-fame th,
        #hall-of-fame td {
            border-bottom: 1px solid #333;
            padding: 4px 3px;
            text-align: left;
        }

        #hall-of-fame th {
            font-weight: 600;
        }

        #game-over-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
        }

        #game-over-box {
            background: #222;
            border-radius: 10px;
            padding: 16px 20px;
            width: 280px;
            max-width: 90vw;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
        }

        #game-over-box h3 {
            margin-top: 0;
            margin-bottom: 8px;
            text-align: center;
        }

        .row {
            margin-bottom: 8px;
        }

        label {
            font-size: 13px;
        }

        input[type="text"] {
            width: 100%;
            padding: 5px 6px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #111;
            color: #fff;
            box-sizing: border-box;
        }

        .buttons {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: space-between;
        }

        button {
            flex: 1;
            padding: 6px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 13px;
            background: #00c56b;
            color: #000;
            font-weight: 600;
            transition: transform 0.05s ease, box-shadow 0.05s ease;
        }

        button.secondary {
            background: #444;
            color: #fff;
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 0 0 rgba(0,0,0,0);
        }
    </style>
</head>
<body>

<!-- Overlay zachęcający do trybu poziomego na telefonie -->
<div id="rotate-overlay">
    <div id="rotate-overlay-inner">
        <h1>Obróć telefon</h1>
        <p>
            Ta gra została zaprojektowana do gry w poziomie (landscape).<br />
            Obróć proszę urządzenie, aby kontynuować.
        </p>
    </div>
</div>

<div class="container">
    <div id="game-wrapper">
        <div style="position: relative;">
            <!-- Logiczny rozmiar gry: 800x400, wizualnie skalowany CSS-em -->
            <canvas id="game" width="800" height="400"></canvas>
            <div id="game-over-overlay">
                <div id="game-over-box">
                    <h3>Koniec gry</h3>
                    <div class="row">
                        <strong>Twój wynik:</strong> <span id="final-score">0</span>
                    </div>
                    <div class="row">
                        <label for="player-name">Twoje imię (max 5 znaków):</label>
                        <input id="player-name" type="text" maxlength="5" />
                    </div>
                    <div class="buttons">
                        <button id="save-score-btn">Zapisz wynik</button>
                        <button id="restart-btn" class="secondary">Graj ponownie</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="ui">
            <div>Punkty: <span id="score">0</span></div>
            <div>Czas: <span id="time">0.0</span>s</div>
            <div>Poziom prędkości: <span id="speed-indicator">1</span>/5</div>
        </div>
        <div id="message">
            Sterowanie: <strong>Spacja</strong> lub <strong>dotknięcie / kliknięcie w obszar gry</strong><br />
            Kapibara biegnie sama – przeskakuj zwierzęta!
        </div>
    </div>

    <div id="hof-panel">
        <h2>Hall of Fame</h2>
        <div id="hall-of-fame">Ładowanie...</div>
    </div>
</div>

<script src="hall_of_fame.js"></script>
<script>
(function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const timeEl = document.getElementById('time');
    const speedIndicatorEl = document.getElementById('speed-indicator');

    const gameOverOverlay = document.getElementById('game-over-overlay');
    const finalScoreEl = document.getElementById('final-score');
    const playerNameInput = document.getElementById('player-name');
    const saveScoreBtn = document.getElementById('save-score-btn');
    const restartBtn = document.getElementById('restart-btn');

    const GRAVITY = 0.5;
    const JUMP_SPEED = -11;
    const GROUND_HEIGHT = 80;

    const BASE_SPEED = 4;

    // 5 poziomów – co 30 sekund:
    // 0-30s: poziom 1, 10 pkt
    // 30-60: poziom 2, 20 pkt
    // 60-90: poziom 3, 30 pkt
    // 90-120: poziom 4, 40 pkt
    // 120+: poziom 5, 50 pkt
    const LEVEL_DURATION = 30;          // w sekundach
    const MAX_LEVEL = 5;               // poziomy 1..5
    const SPEED_LEVELS = [1, 1.2, 1.4, 1.6, 1.8];  // mnożniki prędkości
    const REWARD_LEVELS = [10, 20, 30, 40, 50];    // punkty za przeszkodę

    const CAPY = {
        x: 80,
        y: 0, // ustawi się niżej
        w: 40,
        h: 30,
        vy: 0,
        onGround: false
    };

    let obstacles = [];
    let lastObstacleTime = 0;
    let obstacleInterval = 1400; // ms

    let bgOffset = 0;
    let bgSpeedFactor = 0.5;

    let gameState = 'ready'; // 'ready' | 'running' | 'gameover'
    let startTime = null;
    let lastFrameTime = null;
    let elapsedTime = 0;
    let score = 0;

    let gameOverActionHandled = false;

    function getCurrentLevelIndex() {
        if (!startTime) return 0;
        const levelFromTime = Math.floor(elapsedTime / LEVEL_DURATION);
        return Math.min(levelFromTime, MAX_LEVEL - 1); // indeks 0..4
    }

    function getCurrentSpeed() {
        const lvlIndex = getCurrentLevelIndex();
        return BASE_SPEED * SPEED_LEVELS[lvlIndex];
    }

    function getCurrentReward() {
        const lvlIndex = getCurrentLevelIndex();
        return REWARD_LEVELS[lvlIndex];
    }

    function resetGame() {
        CAPY.y = canvas.height - GROUND_HEIGHT - CAPY.h;
        CAPY.vy = 0;
        CAPY.onGround = true;

        obstacles = [];
        lastObstacleTime = 0;
        bgOffset = 0;

        startTime = null;
        lastFrameTime = null;
        elapsedTime = 0;
        score = 0;
        gameState = 'ready';

        scoreEl.textContent = '0';
        timeEl.textContent = '0.0';
        speedIndicatorEl.textContent = '1';

        gameOverOverlay.style.display = 'none';
        playerNameInput.value = '';

        gameOverActionHandled = false;

        drawFrame(0); // statyczny kadr startowy
    }

    function spawnObstacle(currentTime) {
        const now = currentTime;
        if (now - lastObstacleTime < obstacleInterval) return;

        lastObstacleTime = now;

        // Wybór losowego zwierzęcia
        const animalTypes = ['pies', 'kot', 'żółw', 'ptak', 'świnia'];
        const type = animalTypes[Math.floor(Math.random() * animalTypes.length)];

        // Różne rozmiary w zależności od typu
        let width = 40;
        let height = 40;

        switch (type) {
            case 'pies':
                width = 60; height = 40; break;
            case 'kot':
                width = 50; height = 35; break;
            case 'żółw':
                width = 45; height = 25; break;
            case 'ptak':
                width = 40; height = 30; break;
            case 'świnia':
                width = 55; height = 38; break;
        }

        const x = canvas.width + 20;
        const y = canvas.height - GROUND_HEIGHT - height;

        obstacles.push({
            x,
            y,
            w: width,
            h: height,
            scored: false,
            type
        });
    }

    function doJump() {
        if (gameState === 'ready') {
            startGame();
        }
        if (gameState !== 'running') return;

        if (CAPY.onGround) {
            CAPY.vy = JUMP_SPEED;
            CAPY.onGround = false;
        }
    }

    function startGame() {
        if (gameState === 'running') return;
        gameState = 'running';
        startTime = performance.now();
        lastFrameTime = startTime;
        requestAnimationFrame(gameLoop);
    }

    function endGame() {
        gameState = 'gameover';
        finalScoreEl.textContent = score;
        gameOverOverlay.style.display = 'flex';
    }

    function update(delta, timestamp) {
        const dt = delta / 16.67; // ~60 FPS baseline
        elapsedTime = (timestamp - startTime) / 1000;

        const speed = getCurrentSpeed();
        const lvlIndex = getCurrentLevelIndex();
        speedIndicatorEl.textContent = (lvlIndex + 1).toString();

        // Tło
        bgOffset -= speed * bgSpeedFactor * dt;
        if (bgOffset < -canvas.width) {
            bgOffset += canvas.width;
        }

        // Kapibara – fizyka skoku
        CAPY.vy += GRAVITY * dt;
        CAPY.y += CAPY.vy * dt;

        const groundY = canvas.height - GROUND_HEIGHT - CAPY.h;
        if (CAPY.y >= groundY) {
            CAPY.y = groundY;
            CAPY.vy = 0;
            CAPY.onGround = true;
        }

        // Przeszkody
        spawnObstacle(timestamp);

        for (let i = obstacles.length - 1; i >= 0; i--) {
            const o = obstacles[i];
            o.x -= speed * dt;

            // Kolizja (prosta AABB)
            if (rectOverlap(CAPY, o)) {
                endGame();
                return;
            }

            // Punkty za minięcie "zwierzątka"
            if (!o.scored && (o.x + o.w) < CAPY.x) {
                o.scored = true;
                score += getCurrentReward();
                scoreEl.textContent = score;
            }

            // Usuwanie poza ekranem
            if (o.x + o.w < -50) {
                obstacles.splice(i, 1);
            }
        }

        timeEl.textContent = elapsedTime.toFixed(1);
    }

    function rectOverlap(a, b) {
        return (
            a.x < b.x + b.w &&
            a.x + a.w > b.x &&
            a.y < b.y + b.h &&
            a.y + a.h > b.y
        );
    }

    function drawBackground() {
        const groundY = canvas.height - GROUND_HEIGHT;

        // Ziemia
        ctx.fillStyle = '#5b3b1f';
        ctx.fillRect(0, groundY, canvas.width, GROUND_HEIGHT);

        // Trawa
        ctx.fillStyle = '#3ea63e';
        ctx.fillRect(0, groundY, canvas.width, 8);

        // Linie na ziemi (scrollujące)
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        const stripeWidth = 40;
        for (let x = (bgOffset % stripeWidth) - stripeWidth; x < canvas.width; x += stripeWidth) {
            ctx.fillRect(x, groundY + 12, 20, 3);
        }

        // Proste wzgórza w tle
        ctx.fillStyle = 'rgba(0, 100, 0, 0.5)';
        const hillY = groundY - 60;
        for (let x = ((bgOffset * 0.5) % 200) - 200; x < canvas.width + 200; x += 200) {
            ctx.beginPath();
            ctx.moveTo(x, groundY);
            ctx.quadraticCurveTo(x + 100, hillY - 30, x + 200, groundY);
            ctx.closePath();
            ctx.fill();
        }
    }

    function drawCapybara() {
        // Ciało
        ctx.fillStyle = '#b97a57';
        ctx.fillRect(CAPY.x, CAPY.y, CAPY.w, CAPY.h);

        // Głowa
        ctx.fillRect(CAPY.x + CAPY.w - 10, CAPY.y + 5, 18, 16);

        // Oko
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(CAPY.x + CAPY.w + 4, CAPY.y + 10, 2, 0, Math.PI * 2);
        ctx.fill();

        // Nóżki – prosty efekt biegu
        const legPhase = Math.sin(performance.now() / 80);
        const legOffset = legPhase * 2;
        ctx.fillRect(CAPY.x + 5, CAPY.y + CAPY.h, 6, 8 + legOffset);
        ctx.fillRect(CAPY.x + CAPY.w - 12, CAPY.y + CAPY.h, 6, 8 - legOffset);
    }

    // Rysowanie różnych zwierząt (prostymi kształtami)
    function drawAnimal(o) {
        const { x, y, w, h, type } = o;

        switch (type) {
            case 'pies':
                drawDog(x, y, w, h);
                break;
            case 'kot':
                drawCat(x, y, w, h);
                break;
            case 'żółw':
                drawTurtle(x, y, w, h);
                break;
            case 'ptak':
                drawBird(x, y, w, h);
                break;
            case 'świnia':
                drawPig(x, y, w, h);
                break;
            default:
                // awaryjnie prostokąt
                ctx.fillStyle = '#4b2e16';
                ctx.fillRect(x, y, w, h);
        }
    }

    function drawDog(x, y, w, h) {
        ctx.fillStyle = '#5c3c1f';
        // tułów
        ctx.fillRect(x, y + h * 0.3, w * 0.7, h * 0.6);
        // głowa
        ctx.fillRect(x + w * 0.7, y + h * 0.2, w * 0.35, h * 0.5);
        // uszy
        ctx.fillRect(x + w * 0.78, y + h * 0.05, w * 0.08, h * 0.18);
        // nogi
        ctx.fillRect(x + w * 0.1, y + h * 0.8, w * 0.1, h * 0.2);
        ctx.fillRect(x + w * 0.5, y + h * 0.8, w * 0.1, h * 0.2);
    }

    function drawCat(x, y, w, h) {
        ctx.fillStyle = '#444';
        // tułów
        ctx.fillRect(x, y + h * 0.35, w * 0.7, h * 0.55);
        // głowa
        ctx.fillRect(x + w * 0.55, y + h * 0.15, w * 0.4, h * 0.4);
        // uszy
        ctx.beginPath();
        ctx.moveTo(x + w * 0.6, y + h * 0.15);
        ctx.lineTo(x + w * 0.65, y);
        ctx.lineTo(x + w * 0.7, y + h * 0.15);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(x + w * 0.8, y + h * 0.15);
        ctx.lineTo(x + w * 0.85, y);
        ctx.lineTo(x + w * 0.9, y + h * 0.15);
        ctx.closePath();
        ctx.fill();
        // nogi
        ctx.fillRect(x + w * 0.1, y + h * 0.8, w * 0.1, h * 0.2);
        ctx.fillRect(x + w * 0.5, y + h * 0.8, w * 0.1, h * 0.2);
        // ogon
        ctx.fillRect(x - w * 0.15, y + h * 0.4, w * 0.15, h * 0.12);
    }

    function drawTurtle(x, y, w, h) {
        ctx.fillStyle = '#2f7d32';
        // skorupa – półelipsa
        ctx.beginPath();
        ctx.ellipse(x + w * 0.5, y + h * 0.7, w * 0.5, h * 0.4, 0, Math.PI, 0);
        ctx.closePath();
        ctx.fill();
        // głowa
        ctx.fillRect(x + w * 0.8, y + h * 0.6, w * 0.2, h * 0.2);
        // nogi
        ctx.fillRect(x + w * 0.2, y + h * 0.8, w * 0.15, h * 0.15);
        ctx.fillRect(x + w * 0.6, y + h * 0.8, w * 0.15, h * 0.15);
    }

    function drawBird(x, y, w, h) {
        ctx.fillStyle = '#e0c04f';
        // ciało – elipsa
        ctx.beginPath();
        ctx.ellipse(x + w * 0.4, y + h * 0.6, w * 0.4, h * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();
        // głowa
        ctx.beginPath();
        ctx.arc(x + w * 0.75, y + h * 0.45, h * 0.2, 0, Math.PI * 2);
        ctx.fill();
        // dziób
        ctx.beginPath();
        ctx.moveTo(x + w * 0.9, y + h * 0.45);
        ctx.lineTo(x + w, y + h * 0.42);
        ctx.lineTo(x + w, y + h * 0.48);
        ctx.closePath();
        ctx.fill();
        // nogi
        ctx.fillRect(x + w * 0.35, y + h * 0.8, w * 0.05, h * 0.2);
        ctx.fillRect(x + w * 0.5, y + h * 0.8, w * 0.05, h * 0.2);
    }

    function drawPig(x, y, w, h) {
        ctx.fillStyle = '#d78ca2';
        // tułów
        ctx.fillRect(x, y + h * 0.35, w * 0.7, h * 0.55);
        // głowa
        ctx.fillRect(x + w * 0.6, y + h * 0.25, w * 0.4, h * 0.4);
        // uszy
        ctx.beginPath();
        ctx.moveTo(x + w * 0.65, y + h * 0.25);
        ctx.lineTo(x + w * 0.7, y + h * 0.1);
        ctx.lineTo(x + w * 0.75, y + h * 0.25);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(x + w * 0.8, y + h * 0.25);
        ctx.lineTo(x + w * 0.85, y + h * 0.1);
        ctx.lineTo(x + w * 0.9, y + h * 0.25);
        ctx.closePath();
        ctx.fill();

        // nogi
        ctx.fillRect(x + w * 0.1, y + h * 0.8, w * 0.1, h * 0.2);
        ctx.fillRect(x + w * 0.4, y + h * 0.8, w * 0.1, h * 0.2);
        // ogonek
        ctx.beginPath();
        ctx.moveTo(x - w * 0.05, y + h * 0.5);
        ctx.lineTo(x - w * 0.1, y + h * 0.45);
        ctx.lineTo(x - w * 0.15, y + h * 0.5);
        ctx.strokeStyle = '#d78ca2';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function drawObstacles() {
        obstacles.forEach(o => {
            drawAnimal(o);
        });
    }

    function drawFrame(timestamp) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drawObstacles();
        drawCapybara();
    }

    function gameLoop(timestamp) {
        if (gameState !== 'running') {
            drawFrame(timestamp);
            return;
        }

        if (!lastFrameTime) lastFrameTime = timestamp;
        const delta = timestamp - lastFrameTime;
        lastFrameTime = timestamp;

        update(delta, timestamp);
        drawFrame(timestamp);

        if (gameState === 'running') {
            requestAnimationFrame(gameLoop);
        }
    }

    // Sterowanie – klawiatura (spacja)
    window.addEventListener('keydown', (e) => {
        if (e.code !== 'Space') return;

        // Jeżeli jesteśmy w polu input/textarea lub elemencie edytowalnym – nie skaczemy
        const tag = e.target.tagName.toLowerCase();
        if (tag === 'input' || tag === 'textarea' || e.target.isContentEditable) {
            return;
        }

        e.preventDefault();
        if (gameState === 'gameover') return;
        doJump();
    });

    // Sterowanie – dotyk / kliknięcie dla gry
    function handleTap() {
        if (gameState === 'gameover') return;
        doJump();
    }

    // Kliknięcia myszą – nie reagujemy, gdy klik w okno game over
    window.addEventListener('mousedown', (e) => {
        if (e.target.closest('#game-over-box')) return;
        if (!e.target.closest('#game-wrapper')) return;
        handleTap();
    });

    // Dotyk – tylko obszar gry, nie okno game over
    window.addEventListener('touchstart', (e) => {
        const target = e.target;

        // Jeśli dotykamy okno game over (przyciski, input) – pozwalamy na normalne działanie
        if (target.closest('#game-over-box')) {
            return;
        }

        // Jeśli dotyk jest poza wrapperem gry – np. przewijanie strony – ignorujemy
        if (!target.closest('#game-wrapper')) {
            return;
        }

        if (gameState === 'gameover') return;

        e.preventDefault();
        handleTap();
    }, { passive: false });

    function handleSaveScore() {
        if (gameOverActionHandled) return;
        gameOverActionHandled = true;

        const name = (playerNameInput.value || '').toUpperCase().substring(0, 5) || '???';
        if (window.hof && typeof window.hof.addScore === 'function') {
            window.hof.addScore(name, score);
            window.hof.render(document.getElementById('hall-of-fame'));
        }
        resetGame();
    }

    function handleRestart() {
        if (gameOverActionHandled) return;
        gameOverActionHandled = true;
        resetGame();
    }

    // Game over – obsługa przycisków (klik)
    saveScoreBtn.addEventListener('click', (e) => {
        e.preventDefault();
        handleSaveScore();
    });

    restartBtn.addEventListener('click', (e) => {
        e.preventDefault();
        handleRestart();
    });

    // Game over – obsługa przycisków (tap na telefonie)
    saveScoreBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleSaveScore();
    }, { passive: false });

    restartBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleRestart();
    }, { passive: false });

    // Inicjalizacja – Hall of Fame
    document.addEventListener('DOMContentLoaded', () => {
        if (window.hof && typeof window.hof.render === 'function') {
            window.hof.render(document.getElementById('hall-of-fame'));
        }
    });

    // Start – statyczny ekran
    resetGame();
})();
</script>
</body>
</html>
