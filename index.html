<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Kapibara Runner</title>
    <style>
        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #222;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        /* Overlay proszący o obrócenie telefonu (dla małych ekranów w pionie) */
        #rotate-overlay {
            position: fixed;
            inset: 0;
            background: #111;
            color: #fff;
            display: none;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            z-index: 9999;
        }

        #rotate-overlay-inner {
            max-width: 320px;
            margin: 0 auto;
        }

        #rotate-overlay h1 {
            font-size: 22px;
            margin-bottom: 10px;
        }

        #rotate-overlay p {
            font-size: 16px;
            line-height: 1.4;
        }

        /* Główny kontener (gra + Hall of Fame) */
        .container {
            margin: 10px auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 1000px;
            padding: 0 10px 10px;
            box-sizing: border-box;
            align-items: center;
        }

        @media (min-width: 900px) {
            .container {
                align-items: flex-start;
            }
        }

        /* Kontener do skalowania całej gry tak, by mieściła się na ekranie */
        #game-scale {
            position: relative;
        }

        #game-wrapper {
            background: #111;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            width: 800px;       /* bazowa szerokość interfejsu */
            box-sizing: border-box;
        }

        canvas {
            display: block;
            background: linear-gradient(#7fd4ff, #b5e8ff);
            border-radius: 8px;
            width: 100%;
            height: auto;      /* zachowuje proporcje 800x400 */
        }

        #ui {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            gap: 5px;
            flex-wrap: wrap;
        }

        #message {
            margin-top: 8px;
            font-size: 14px;
        }

        #hof-panel {
            background: #111;
            padding: 10px 14px;
            border-radius: 8px;
            min-width: 0;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 400px;
        }

        #hof-panel h2 {
            margin-top: 0;
            font-size: 18px;
            text-align: center;
        }

        #hall-of-fame table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        #hall-of-fame th,
        #hall-of-fame td {
            border-bottom: 1px solid #333;
            padding: 4px 3px;
            text-align: left;
        }

        #hall-of-fame th {
            font-weight: 600;
        }

        #game-over-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
        }

        #game-over-box {
            background: #222;
            border-radius: 10px;
            padding: 16px 20px;
            width: 280px;
            max-width: 90vw;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
        }

        #game-over-box h3 {
            margin-top: 0;
            margin-bottom: 8px;
            text-align: center;
        }

        .row {
            margin-bottom: 8px;
        }

        label {
            font-size: 13px;
        }

        input[type="text"] {
            width: 100%;
            padding: 5px 6px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #111;
            color: #fff;
            box-sizing: border-box;
        }

        .buttons {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: space-between;
        }

        button {
            flex: 1;
            padding: 6px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 13px;
            background: #00c56b;
            color: #000;
            font-weight: 600;
            transition: transform 0.05s ease, box-shadow 0.05s ease;
        }

        button.secondary {
            background: #444;
            color: #fff;
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 0 0 rgba(0,0,0,0);
        }

        /* Drobne zmiany dla bardzo niskich ekranów (mały landscape) */
        @media (max-height: 480px) {
            #ui {
                font-size: 12px;
            }
            #message {
                font-size: 12px;
            }
            button {
                font-size: 12px;
                padding: 4px;
            }
        }
    </style>
</head>
<body>

<!-- Overlay proszący o tryb poziomy na małych urządzeniach w pionie -->
<div id="rotate-overlay">
    <div id="rotate-overlay-inner">
        <h1>Obróć telefon</h1>
        <p>
            Ta gra została zaprojektowana do gry w poziomie (landscape).<br />
            Obróć proszę urządzenie, aby kontynuować.
        </p>
    </div>
</div>

<div class="container" id="main-container">
    <div id="game-scale">
        <div id="game-wrapper">
            <div style="position: relative;">
                <!-- Logiczny rozmiar gry: 800x400 -->
                <canvas id="game" width="800" height="400"></canvas>
                <div id="game-over-overlay">
                    <div id="game-over-box">
                        <h3>Koniec gry</h3>
                        <div class="row">
                            <strong>Twój wynik:</strong> <span id="final-score">0</span>
                        </div>
                        <div class="row">
                            <label for="player-name">Twoje imię (max 5 znaków):</label>
                            <input id="player-name" type="text" maxlength="5" />
                        </div>
                        <div class="buttons">
                            <button id="save-score-btn">Zapisz wynik</button>
                            <button id="restart-btn" class="secondary">Graj ponownie</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="ui">
                <div>Punkty: <span id="score">0</span></div>
                <div>Czas: <span id="time">0.0</span>s</div>
                <div>Poziom prędkości: <span id="speed-indicator">1</span>/5</div>
            </div>
            <div id="message">
                Sterowanie: <strong>Spacja</strong> lub <strong>dotknięcie / kliknięcie w obszar gry</strong><br />
                Kapibara biegnie sama – przeskakuj egzotyczne zwierzęta!
            </div>
        </div>
    </div>

    <div id="hof-panel">
        <h2>Hall of Fame</h2>
        <div id="hall-of-fame">Ładowanie...</div>
    </div>
</div>

<script src="hall_of_fame.js"></script>
<script>
(function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const timeEl = document.getElementById('time');
    const speedIndicatorEl = document.getElementById('speed-indicator');

    const gameOverOverlay = document.getElementById('game-over-overlay');
    const finalScoreEl = document.getElementById('final-score');
    const playerNameInput = document.getElementById('player-name');
    const saveScoreBtn = document.getElementById('save-score-btn');
    const restartBtn = document.getElementById('restart-btn');

    const overlayEl = document.getElementById('rotate-overlay');
    const mainContainerEl = document.getElementById('main-container');
    const scaleContainerEl = document.getElementById('game-scale');
    const gameWrapperEl = document.getElementById('game-wrapper');

    const GRAVITY = 0.5;
    const JUMP_SPEED = -11;
    const GROUND_HEIGHT = 80;

    const BASE_SPEED = 4;

    // 5 poziomów – co 30 sekund:
    // 0-30s: poziom 1, 10 pkt
    // 30-60: poziom 2, 20 pkt
    // 60-90: poziom 3, 30 pkt
    // 90-120: poziom 4, 40 pkt
    // 120+: poziom 5, 50 pkt
    const LEVEL_DURATION = 30;          // w sekundach
    const MAX_LEVEL = 5;               // poziomy 1..5
    const SPEED_LEVELS = [1, 1.2, 1.4, 1.6, 1.8];  // mnożniki prędkości
    const REWARD_LEVELS = [10, 20, 30, 40, 50];    // punkty za przeszkodę

    const CAPY = {
        x: 80,
        y: 0, // ustawi się niżej
        w: 40,
        h: 30,
        vy: 0,
        onGround: false
    };

    let obstacles = [];
    let lastObstacleTime = 0;
    let obstacleInterval = 1400; // ms

    let bgOffset = 0;
    let bgSpeedFactor = 0.5;

    // Osobne offsety chmur – słońce jest nieruchome
    let cloudOffset1 = 0;
    let cloudOffset2 = 0;
    let cloudOffset3 = 0;

    let gameState = 'ready'; // 'ready' | 'running' | 'gameover'
    let startTime = null;
    let lastFrameTime = null;
    let elapsedTime = 0;
    let score = 0;

    let gameOverActionHandled = false;

    // Do skalowania interfejsu gry
    let baseGameWidth = null;
    let baseGameHeight = null;

    function getCurrentLevelIndex() {
        if (!startTime) return 0;
        const levelFromTime = Math.floor(elapsedTime / LEVEL_DURATION);
        return Math.min(levelFromTime, MAX_LEVEL - 1); // indeks 0..4
    }

    function getCurrentSpeed() {
        const lvlIndex = getCurrentLevelIndex();
        return BASE_SPEED * SPEED_LEVELS[lvlIndex];
    }

    function getCurrentReward() {
        const lvlIndex = getCurrentLevelIndex();
        return REWARD_LEVELS[lvlIndex];
    }

    function resetGame() {
        CAPY.y = canvas.height - GROUND_HEIGHT - CAPY.h;
        CAPY.vy = 0;
        CAPY.onGround = true;

        obstacles = [];
        lastObstacleTime = 0;
        bgOffset = 0;

        cloudOffset1 = 0;
        cloudOffset2 = 0;
        cloudOffset3 = 0;

        startTime = null;
        lastFrameTime = null;
        elapsedTime = 0;
        score = 0;
        gameState = 'ready';

        scoreEl.textContent = '0';
        timeEl.textContent = '0.0';
        speedIndicatorEl.textContent = '1';

        gameOverOverlay.style.display = 'none';
        playerNameInput.value = '';

        gameOverActionHandled = false;

        drawFrame(0); // statyczny kadr startowy
    }

    function spawnObstacle(currentTime) {
        const now = currentTime;
        if (now - lastObstacleTime < obstacleInterval) return;

        lastObstacleTime = now;

        // egzotyczne zwierzęta
        const animalTypes = [
            'słoń', 'małpa', 'krokodyl', 'pantera', 'papuga',
            'wąż', 'nosorożec', 'zebra', 'lew', 'guziec'
        ];
        const type = animalTypes[Math.floor(Math.random() * animalTypes.length)];

        // Bazowe rozmiary zbliżone do wcześniejszych „domowych” zwierząt
        // (dostosowane do najniższej prędkości tak, żeby dało się przeskakiwać)
        let baseW = 60;
        let baseH = 40;

        switch (type) {
            case 'słoń':
                baseW = 60; baseH = 40; break;
            case 'małpa':
                baseW = 50; baseH = 40; break;
            case 'krokodyl':
                baseW = 60; baseH = 30; break;
            case 'pantera':
                baseW = 60; baseH = 35; break;
            case 'papuga':
                baseW = 40; baseH = 30; break;
            case 'wąż':
                baseW = 60; baseH = 25; break;
            case 'nosorożec':
                baseW = 60; baseH = 45; break;
            case 'zebra':
                baseW = 60; baseH = 45; break;
            case 'lew':
                baseW = 60; baseH = 40; break;
            case 'guziec':
                baseW = 55; baseH = 38; break;
        }

        // Skalowanie rozmiaru zwierzęcia zależnie od poziomu prędkości:
        // poziom 1 – bazowy rozmiar, kolejne poziomy stopniowo większe
        const lvlIndex = getCurrentLevelIndex(); // 0..4
        const sizeFactor = 1 + lvlIndex * 0.2;   // 1.0, 1.2, 1.4, 1.6, 1.8

        const width = baseW * sizeFactor;
        const height = baseH * sizeFactor;

        const x = canvas.width + 20;
        const y = canvas.height - GROUND_HEIGHT - height;

        obstacles.push({
            x,
            y,
            w: width,
            h: height,
            scored: false,
            type
        });
    }

    function doJump() {
        if (gameState === 'ready') {
            startGame();
        }
        if (gameState !== 'running') return;

        if (CAPY.onGround) {
            CAPY.vy = JUMP_SPEED;
            CAPY.onGround = false;
        }
    }

    function startGame() {
        if (gameState === 'running') return;
        gameState = 'running';
        startTime = performance.now();
        lastFrameTime = startTime;
        requestAnimationFrame(gameLoop);
    }

    function endGame() {
        gameState = 'gameover';
        finalScoreEl.textContent = score;
        gameOverOverlay.style.display = 'flex';
    }

    function update(delta, timestamp) {
        const dt = delta / 16.67; // ~60 FPS baseline
        elapsedTime = (timestamp - startTime) / 1000;

        const speed = getCurrentSpeed();
        const lvlIndex = getCurrentLevelIndex();
        speedIndicatorEl.textContent = (lvlIndex + 1).toString();

        // Tło – grunt i wzgórza przewijają się z prędkością gry
        bgOffset -= speed * bgSpeedFactor * dt;
        if (bgOffset < -canvas.width) {
            bgOffset += canvas.width;
        }

        // Chmury – osobne, wolniejsze przesuwanie, niezależne od prędkości gry
        cloudOffset1 -= 0.3 * dt;
        cloudOffset2 -= 0.2 * dt;
        cloudOffset3 -= 0.1 * dt;

        // Kapibara – fizyka skoku
        CAPY.vy += GRAVITY * dt;
        CAPY.y += CAPY.vy * dt;

        const groundY = canvas.height - GROUND_HEIGHT - CAPY.h;
        if (CAPY.y >= groundY) {
            CAPY.y = groundY;
            CAPY.vy = 0;
            CAPY.onGround = true;
        }

        // Przeszkody
        spawnObstacle(timestamp);

        for (let i = obstacles.length - 1; i >= 0; i--) {
            const o = obstacles[i];
            o.x -= speed * dt;

            // Kolizja (prosta AABB)
            if (rectOverlap(CAPY, o)) {
                endGame();
                return;
            }

            // Punkty za minięcie zwierzęcia
            if (!o.scored && (o.x + o.w) < CAPY.x) {
                o.scored = true;
                score += getCurrentReward();
                scoreEl.textContent = score;
            }

            // Usuwanie poza ekranem
            if (o.x + o.w < -50) {
                obstacles.splice(i, 1);
            }
        }

        timeEl.textContent = elapsedTime.toFixed(1);
    }

    function rectOverlap(a, b) {
        return (
            a.x < b.x + b.w &&
            a.x + a.w > b.x &&
            a.y < b.y + b.h &&
            a.y + a.h > b.y
        );
    }

    function drawBackground() {
        const groundY = canvas.height - GROUND_HEIGHT;

        // Słońce – nieruchome
        ctx.save();
        ctx.fillStyle = '#FFD54F';
        ctx.beginPath();
        ctx.arc(canvas.width - 80, 70, 40, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Chmury – poruszają się powoli w poziomie
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        const cloudBaseY1 = 70;
        const cloudBaseY2 = 120;
        const cloudBaseY3 = 50;
        const cloudSpacing = 220;

        for (let x = (cloudOffset1 % cloudSpacing) - cloudSpacing; x < canvas.width + cloudSpacing; x += cloudSpacing) {
            drawCloud(x, cloudBaseY1);
        }
        for (let x = (cloudOffset2 % cloudSpacing) - cloudSpacing; x < canvas.width + cloudSpacing; x += cloudSpacing) {
            drawCloud(x, cloudBaseY2, 0.8);
        }
        for (let x = (cloudOffset3 % cloudSpacing) - cloudSpacing; x < canvas.width + cloudSpacing; x += cloudSpacing) {
            drawCloud(x, cloudBaseY3, 0.7);
        }
        ctx.restore();

        // Ziemia
        ctx.fillStyle = '#5b3b1f';
        ctx.fillRect(0, groundY, canvas.width, GROUND_HEIGHT);

        // Trawa
        ctx.fillStyle = '#3ea63e';
        ctx.fillRect(0, groundY, canvas.width, 8);

        // Linie na ziemi (scrollujące)
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        const stripeWidth = 40;
        for (let x = (bgOffset % stripeWidth) - stripeWidth; x < canvas.width; x += stripeWidth) {
            ctx.fillRect(x, groundY + 12, 20, 3);
        }

        // Proste wzgórza w tle
        ctx.fillStyle = 'rgba(0, 100, 0, 0.5)';
        const hillY = groundY - 60;
        for (let x = ((bgOffset * 0.5) % 200) - 200; x < canvas.width + 200; x += 200) {
            ctx.beginPath();
            ctx.moveTo(x, groundY);
            ctx.quadraticCurveTo(x + 100, hillY - 30, x + 200, groundY);
            ctx.closePath();
            ctx.fill();
        }
    }

    function drawCloud(cx, cy, scale = 1) {
        const w = 70 * scale;
        const h = 35 * scale;

        ctx.beginPath();
        ctx.ellipse(cx, cy, w * 0.6, h * 0.6, 0, 0, Math.PI * 2);
        ctx.ellipse(cx - w * 0.4, cy + 5 * scale, w * 0.45, h * 0.45, 0, 0, Math.PI * 2);
        ctx.ellipse(cx + w * 0.4, cy + 2 * scale, w * 0.4, h * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawCapybara() {
        // Ciało
        ctx.fillStyle = '#b97a57';
        ctx.fillRect(CAPY.x, CAPY.y, CAPY.w, CAPY.h);

        // Głowa (po prawej, biegnie w prawo, przeszkody w lewo)
        ctx.fillRect(CAPY.x + CAPY.w - 10, CAPY.y + 5, 18, 16);

        // Oko
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(CAPY.x + CAPY.w + 4, CAPY.y + 10, 2, 0, Math.PI * 2);
        ctx.fill();

        // Nóżki – prosty efekt biegu
        const legPhase = Math.sin(performance.now() / 80);
        const legOffset = legPhase * 2;
        ctx.fillRect(CAPY.x + 5, CAPY.y + CAPY.h, 6, 8 + legOffset);
        ctx.fillRect(CAPY.x + CAPY.w - 12, CAPY.y + CAPY.h, 6, 8 - legOffset);
    }

    // Rysowanie egzotycznych zwierząt, zwróconych w LEWĄ stronę (głowa po lewej)
    function drawAnimal(o) {
        const { x, y, w, h, type } = o;

        switch (type) {
            case 'słoń':
                drawElephant(x, y, w, h);
                break;
            case 'małpa':
                drawMonkey(x, y, w, h);
                break;
            case 'krokodyl':
                drawCrocodile(x, y, w, h);
                break;
            case 'pantera':
                drawPanther(x, y, w, h);
                break;
            case 'papuga':
                drawParrot(x, y, w, h);
                break;
            case 'wąż':
                drawSnake(x, y, w, h);
                break;
            case 'nosorożec':
                drawRhino(x, y, w, h);
                break;
            case 'zebra':
                drawZebra(x, y, w, h);
                break;
            case 'lew':
                drawLion(x, y, w, h);
                break;
            case 'guziec':
                drawWarthog(x, y, w, h);
                break;
            default:
                ctx.fillStyle = '#4b2e16';
                ctx.fillRect(x, y, w, h);
        }
    }

    function drawElephant(x, y, w, h) {
        ctx.fillStyle = '#9ea7b8';
        // tułów
        ctx.fillRect(x + w * 0.3, y + h * 0.3, w * 0.6, h * 0.6);
        // głowa (po lewej)
        ctx.fillRect(x, y + h * 0.25, w * 0.35, h * 0.5);
        // trąba w lewo
        ctx.fillRect(x - w * 0.15, y + h * 0.45, w * 0.15, h * 0.15);
        // nogi
        ctx.fillRect(x + w * 0.35, y + h * 0.8, w * 0.12, h * 0.2);
        ctx.fillRect(x + w * 0.6, y + h * 0.8, w * 0.12, h * 0.2);
        // ucho
        ctx.fillRect(x + w * 0.1, y + h * 0.3, w * 0.15, h * 0.25);
    }

    function drawMonkey(x, y, w, h) {
        ctx.fillStyle = '#8b5a2b';
        // tułów
        ctx.fillRect(x + w * 0.35, y + h * 0.35, w * 0.45, h * 0.5);
        // głowa
        ctx.beginPath();
        ctx.arc(x + w * 0.25, y + h * 0.45, h * 0.22, 0, Math.PI * 2);
        ctx.fill();
        // twarz jaśniejsza
        ctx.fillStyle = '#c49a6c';
        ctx.beginPath();
        ctx.ellipse(x + w * 0.25, y + h * 0.5, w * 0.18, h * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();
        // ogon (z prawej)
        ctx.strokeStyle = '#8b5a2b';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x + w * 0.8, y + h * 0.4);
        ctx.quadraticCurveTo(x + w * 0.95, y + h * 0.2, x + w * 0.9, y + h * 0.05);
        ctx.stroke();
        // nogi
        ctx.fillStyle = '#8b5a2b';
        ctx.fillRect(x + w * 0.4, y + h * 0.8, w * 0.08, h * 0.2);
        ctx.fillRect(x + w * 0.6, y + h * 0.8, w * 0.08, h * 0.2);
    }

    function drawCrocodile(x, y, w, h) {
        ctx.fillStyle = '#2e7d32';
        // ciało
        ctx.fillRect(x + w * 0.2, y + h * 0.4, w * 0.7, h * 0.4);
        // głowa po lewej
        ctx.fillRect(x, y + h * 0.35, w * 0.25, h * 0.4);
        // grzbietowe zęby
        ctx.fillStyle = '#1b5e20';
        for (let i = 0; i < 6; i++) {
            const cx = x + w * (0.25 + i * 0.1);
            const cy = y + h * 0.35;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + 6, cy - 8);
            ctx.lineTo(cx + 12, cy);
            ctx.closePath();
            ctx.fill();
        }
    }

    function drawPanther(x, y, w, h) {
        ctx.fillStyle = '#111';
        // tułów
        ctx.fillRect(x + w * 0.3, y + h * 0.35, w * 0.6, h * 0.4);
        // głowa po lewej
        ctx.fillRect(x + w * 0.1, y + h * 0.3, w * 0.25, h * 0.3);
        // uszy
        ctx.beginPath();
        ctx.moveTo(x + w * 0.15, y + h * 0.3);
        ctx.lineTo(x + w * 0.18, y + h * 0.18);
        ctx.lineTo(x + w * 0.22, y + h * 0.3);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + w * 0.24, y + h * 0.3);
        ctx.lineTo(x + w * 0.27, y + h * 0.18);
        ctx.lineTo(x + w * 0.31, y + h * 0.3);
        ctx.closePath();
        ctx.fill();
        // nogi
        ctx.fillRect(x + w * 0.35, y + h * 0.75, w * 0.1, h * 0.25);
        ctx.fillRect(x + w * 0.6, y + h * 0.75, w * 0.1, h * 0.25);
        // ogon w górę
        ctx.beginPath();
        ctx.moveTo(x + w * 0.9, y + h * 0.45);
        ctx.quadraticCurveTo(x + w, y + h * 0.25, x + w * 0.95, y + h * 0.1);
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 4;
        ctx.stroke();
    }

    function drawParrot(x, y, w, h) {
        ctx.fillStyle = '#e53935';
        // ciało (owal)
        ctx.beginPath();
        ctx.ellipse(x + w * 0.4, y + h * 0.55, w * 0.35, h * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();
        // głowa
        ctx.beginPath();
        ctx.arc(x + w * 0.2, y + h * 0.4, h * 0.2, 0, Math.PI * 2);
        ctx.fill();
        // dziób w lewo
        ctx.fillStyle = '#ffca28';
        ctx.beginPath();
        ctx.moveTo(x + w * 0.05, y + h * 0.4);
        ctx.lineTo(x, y + h * 0.37);
        ctx.lineTo(x, y + h * 0.43);
        ctx.closePath();
        ctx.fill();
        // skrzydło
        ctx.fillStyle = '#c62828';
        ctx.beginPath();
        ctx.ellipse(x + w * 0.45, y + h * 0.6, w * 0.25, h * 0.22, 0, 0, Math.PI * 2);
        ctx.fill();
        // ogon
        ctx.fillRect(x + w * 0.65, y + h * 0.7, w * 0.1, h * 0.4);
    }

    function drawSnake(x, y, w, h) {
        ctx.fillStyle = '#4caf50';
        // ciało - falujący pasek od prawej do lewej
        const segments = 6;
        const segmentWidth = w / segments;
        ctx.beginPath();
        ctx.moveTo(x + w, y + h * 0.6);
        for (let i = 0; i <= segments; i++) {
            const px = x + w - i * segmentWidth;
            const offset = (i % 2 === 0) ? -h * 0.15 : h * 0.15;
            ctx.lineTo(px, y + h * 0.6 + offset);
        }
        ctx.lineWidth = h * 0.3;
        ctx.strokeStyle = '#4caf50';
        ctx.stroke();

        // głowa po lewej
        ctx.fillStyle = '#43a047';
        ctx.fillRect(x, y + h * 0.45, w * 0.15, h * 0.3);
    }

    function drawRhino(x, y, w, h) {
        ctx.fillStyle = '#757575';
        // tułów
        ctx.fillRect(x + w * 0.35, y + h * 0.35, w * 0.55, h * 0.5);
        // głowa po lewej
        ctx.fillRect(x + w * 0.1, y + h * 0.3, w * 0.3, h * 0.4);
        // róg
        ctx.fillStyle = '#bdbdbd';
        ctx.beginPath();
        ctx.moveTo(x, y + h * 0.35);
        ctx.lineTo(x - w * 0.1, y + h * 0.3);
        ctx.lineTo(x - w * 0.05, y + h * 0.4);
        ctx.closePath();
        ctx.fill();
        // nogi
        ctx.fillStyle = '#757575';
        ctx.fillRect(x + w * 0.4, y + h * 0.8, w * 0.12, h * 0.2);
        ctx.fillRect(x + w * 0.65, y + h * 0.8, w * 0.12, h * 0.2);
    }

    function drawZebra(x, y, w, h) {
        ctx.fillStyle = '#fafafa';
        // tułów
        ctx.fillRect(x + w * 0.3, y + h * 0.35, w * 0.6, h * 0.45);
        // paski
        ctx.fillStyle = '#212121';
        for (let i = 0; i < 6; i++) {
            const sx = x + w * (0.32 + i * 0.1);
            ctx.fillRect(sx, y + h * 0.35, w * 0.03, h * 0.45);
        }
        // głowa
        ctx.fillStyle = '#fafafa';
        ctx.fillRect(x + w * 0.1, y + h * 0.3, w * 0.25, h * 0.3);
        ctx.fillStyle = '#212121';
        ctx.fillRect(x + w * 0.12, y + h * 0.32, w * 0.04, h * 0.2); // pasek na głowie
        // uszy
        ctx.beginPath();
        ctx.moveTo(x + w * 0.15, y + h * 0.3);
        ctx.lineTo(x + w * 0.18, y + h * 0.18);
        ctx.lineTo(x + w * 0.21, y + h * 0.3);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + w * 0.23, y + h * 0.3);
        ctx.lineTo(x + w * 0.26, y + h * 0.18);
        ctx.lineTo(x + w * 0.29, y + h * 0.3);
        ctx.closePath();
        ctx.fill();
        // nogi
        ctx.fillRect(x + w * 0.35, y + h * 0.8, w * 0.1, h * 0.2);
        ctx.fillRect(x + w * 0.6, y + h * 0.8, w * 0.1, h * 0.2);
        // ogon
        ctx.fillRect(x + w * 0.88, y + h * 0.45, w * 0.05, h * 0.3);
    }

    function drawLion(x, y, w, h) {
        ctx.fillStyle = '#f9a825';
        // tułów
        ctx.fillRect(x + w * 0.35, y + h * 0.4, w * 0.55, h * 0.4);
        // głowa po lewej z grzywą
        ctx.fillStyle = '#ffb300';
        ctx.beginPath();
        ctx.arc(x + w * 0.25, y + h * 0.5, h * 0.23, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#f57f17';
        ctx.beginPath();
        ctx.arc(x + w * 0.25, y + h * 0.5, h * 0.3, 0, Math.PI * 2);
        ctx.fill();
        // nogi
        ctx.fillStyle = '#f9a825';
        ctx.fillRect(x + w * 0.4, y + h * 0.8, w * 0.1, h * 0.2);
        ctx.fillRect(x + w * 0.65, y + h * 0.8, w * 0.1, h * 0.2);
        // ogon
        ctx.beginPath();
        ctx.moveTo(x + w * 0.9, y + h * 0.45);
        ctx.quadraticCurveTo(x + w, y + h * 0.4, x + w * 0.98, y + h * 0.3);
        ctx.strokeStyle = '#f9a825';
        ctx.lineWidth = 3;
        ctx.stroke();
    }

    function drawWarthog(x, y, w, h) {
        ctx.fillStyle = '#8d6e63';
        // tułów
        ctx.fillRect(x + w * 0.35, y + h * 0.4, w * 0.55, h * 0.4);
        // głowa po lewej
        ctx.fillRect(x + w * 0.1, y + h * 0.35, w * 0.3, h * 0.35);
        // kły
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(x + w * 0.1, y + h * 0.55);
        ctx.lineTo(x, y + h * 0.5);
        ctx.lineTo(x + w * 0.05, y + h * 0.6);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + w * 0.1, y + h * 0.45);
        ctx.lineTo(x, y + h * 0.4);
        ctx.lineTo(x + w * 0.05, y + h * 0.5);
        ctx.closePath();
        ctx.fill();
        // nogi
        ctx.fillStyle = '#8d6e63';
        ctx.fillRect(x + w * 0.4, y + h * 0.8, w * 0.1, h * 0.2);
        ctx.fillRect(x + w * 0.65, y + h * 0.8, w * 0.1, h * 0.2);
        // grzywa na grzbiecie
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(x + w * 0.45, y + h * 0.32, w * 0.2, h * 0.08);
    }

    function drawObstacles() {
        obstacles.forEach(o => {
            drawAnimal(o);
        });
    }

    function drawFrame(timestamp) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drawObstacles();
        drawCapybara();
    }

    function gameLoop(timestamp) {
        if (gameState !== 'running') {
            drawFrame(timestamp);
            return;
        }

        if (!lastFrameTime) lastFrameTime = timestamp;
        const delta = timestamp - lastFrameTime;
        lastFrameTime = timestamp;

        update(delta, timestamp);
        drawFrame(timestamp);

        if (gameState === 'running') {
            requestAnimationFrame(gameLoop);
        }
    }

    // Sterowanie – klawiatura (spacja)
    window.addEventListener('keydown', (e) => {
        if (e.code !== 'Space') return;

        const tag = e.target.tagName.toLowerCase();
        if (tag === 'input' || tag === 'textarea' || e.target.isContentEditable) {
            return;
        }

        e.preventDefault();
        if (gameState === 'gameover') return;
        doJump();
    });

    // Sterowanie – dotyk / kliknięcie dla gry
    function handleTap() {
        if (gameState === 'gameover') return;
        doJump();
    }

    // Kliknięcia myszą – tylko w obszarze gry, nie w okienku game over
    window.addEventListener('mousedown', (e) => {
        if (e.target.closest('#game-over-box')) return;
        if (!e.target.closest('#game-wrapper')) return;
        handleTap();
    });

    // Dotyk – tylko obszar gry, nie okno game over
    window.addEventListener('touchstart', (e) => {
        const target = e.target;

        if (target.closest('#game-over-box')) {
            return;
        }

        if (!target.closest('#game-wrapper')) {
            return;
        }

        if (gameState === 'gameover') return;

        e.preventDefault();
        handleTap();
    }, { passive: false });

    function handleSaveScore() {
        if (gameOverActionHandled) return;
        gameOverActionHandled = true;

        const name = (playerNameInput.value || '').toUpperCase().substring(0, 5) || '???';
        if (window.hof && typeof window.hof.addScore === 'function') {
            window.hof.addScore(name, score);
            window.hof.render(document.getElementById('hall-of-fame'));
        }
        resetGame();
    }

    function handleRestart() {
        if (gameOverActionHandled) return;
        gameOverActionHandled = true;
        resetGame();
    }

    // Game over – obsługa przycisków (klik)
    saveScoreBtn.addEventListener('click', (e) => {
        e.preventDefault();
        handleSaveScore();
    });

    restartBtn.addEventListener('click', (e) => {
        e.preventDefault();
        handleRestart();
    });

    // Game over – obsługa przycisków (tap na telefonie)
    saveScoreBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleSaveScore();
    }, { passive: false });

    restartBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleRestart();
    }, { passive: false });

    // Skalowanie interfejsu gry, aby mieścił się w oknie
    function resizeGameArea() {
        if (!gameWrapperEl || !scaleContainerEl) return;

        gameWrapperEl.style.transform = 'scale(1)';
        gameWrapperEl.style.transformOrigin = 'top left';

        if (baseGameWidth === null || baseGameHeight === null) {
            baseGameWidth = gameWrapperEl.offsetWidth;
            baseGameHeight = gameWrapperEl.offsetHeight;
        }

        if (!baseGameWidth || !baseGameHeight) return;

        const padding = 10;
        const availWidth = window.innerWidth - padding * 2;
        const availHeight = window.innerHeight - padding * 2;

        const scale = Math.min(
            availWidth / baseGameWidth,
            availHeight / baseGameHeight,
            1
        );

        gameWrapperEl.style.transform = 'scale(' + scale + ')';
        gameWrapperEl.style.transformOrigin = 'top left';

        scaleContainerEl.style.width = (baseGameWidth * scale) + 'px';
        scaleContainerEl.style.height = (baseGameHeight * scale) + 'px';
    }

    // Pokazywanie/ukrywanie overlayu "obróć telefon" + skalowanie
    function updateLayout() {
        if (!mainContainerEl || !overlayEl) return;

        const isPortrait = window.innerHeight > window.innerWidth;
        const isSmallDevice = window.innerWidth < 900;

        if (isPortrait && isSmallDevice) {
            overlayEl.style.display = 'flex';
            mainContainerEl.style.display = 'none';
        } else {
            overlayEl.style.display = 'none';
            mainContainerEl.style.display = 'flex';
            resizeGameArea();
        }
    }

    // Inicjalizacja – Hall of Fame
    if (window.hof && typeof window.hof.render === 'function') {
        window.hof.render(document.getElementById('hall-of-fame'));
    }

    // Start – statyczny ekran
    resetGame();

    // Ustawienie layoutu i skalowanie na starcie oraz przy zmianie rozmiaru / orientacji
    updateLayout();
    window.addEventListener('resize', updateLayout);

})();
</script>
</body>
</html>
